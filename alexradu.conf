# /etc/nginx/conf.d/selfhost.conf
# Unified nginx configuration for meeting.your-domain.example.com (Rallly app)
# and files.your-domain.example.com (MinIO)
# Strategy: Proxy all dynamic/content to upstream containers; let Next.js serve static but ensure
# proper caching for immutable assets and prevent HTML fallback caching.

# -------------------------------
# Upstreams
# -------------------------------
upstream rallly_app {
    # Point to your Rallly container / host
    server 127.0.0.1:3333;
    keepalive 32;
}

upstream minio_api {
    server 127.0.0.1:9000;  # or minio:9000 inside docker network
    keepalive 16;
}

upstream minio_console {
    server 127.0.0.1:9001;  # or minio:9001 inside docker network
    keepalive 8;
}

# -------------------------------
# Shared proxy settings (can be included via include if split)
# -------------------------------
map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

# Force real scheme when behind Cloudflare or similar
map $http_cf_visitor $real_proto_cf {
    default '';
    '~"scheme":"https"' https;
}

# Derive forwarded proto (Cloudflare OR native TLS)
map $real_proto_cf $forwarded_proto {
    default $scheme;
    https  https;
}

# Security headers (tuned minimal; extend as needed)
add_header X-Frame-Options DENY always;
add_header X-Content-Type-Options nosniff always;
add_header Referrer-Policy strict-origin-when-cross-origin always;
add_header X-XSS-Protection "1; mode=block" always;
add_header Permissions-Policy "camera=(), microphone=(), geolocation=()" always;
# NOTE: Add a CSP once chunk delivery fixed to avoid masking root causes.

# -------------------------------
# Rallly Application: meeting.your-domain.example.com
# -------------------------------
server {
    listen 80;
    server_name meeting.your-domain.example.com;

    # Redirect http->https if TLS termination is local. If Cloudflare provides TLS and origin is http only, comment out.
    if ($forwarded_proto != 'https') {
        return 301 https://$host$request_uri;
    }

    # Real IP (Cloudflare). Adjust list or use realip module config if installed.
    set_real_ip_from 173.245.48.0/20;
    set_real_ip_from 103.21.244.0/22;
    set_real_ip_from 103.22.200.0/22;
    set_real_ip_from 103.31.4.0/22;
    set_real_ip_from 141.101.64.0/18;
    set_real_ip_from 108.162.192.0/18;
    set_real_ip_from 190.93.240.0/20;
    set_real_ip_from 188.114.96.0/20;
    set_real_ip_from 197.234.240.0/22;
    set_real_ip_from 198.41.128.0/17;
    set_real_ip_from 162.158.0.0/15;
    set_real_ip_from 104.16.0.0/13;
    set_real_ip_from 104.24.0.0/14;
    set_real_ip_from 172.64.0.0/13;
    set_real_ip_from 131.0.72.0/22;
    real_ip_header CF-Connecting-IP;

    # Log format helpful for debugging chunk issue
    access_log /var/log/nginx/meeting.access.log;
    error_log  /var/log/nginx/meeting.error.log warn;

    # --- Critical: static chunks must not be rewritten ---
    # We proxy them directly to Next.js, preserving origin headers. Next adds immutable headers.
    location ~* ^/_next/static/ {
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Proto $forwarded_proto;
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_pass http://rallly_app;
        proxy_read_timeout 60s;
        # Ensure we never cache accidental HTML here at the edge (leave caching to CF rules for 200 JS).
        proxy_intercept_errors off;
    }

    # Image optimization endpoint
    location ^~ /_next/image {
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Proto $forwarded_proto;
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_pass http://rallly_app;
        proxy_read_timeout 60s;
    }

    # Static public assets (if any served under /public via Next) - let Next handle, no rewrite
    location ^~ /favicon.ico { proxy_pass http://rallly_app; }
    location ^~ /robots.txt { proxy_pass http://rallly_app; }

    # Websocket / edge runtime (Next dev features / potentially next-auth ws in future)
    location /_next/webpack-hmr {  # mainly dev but harmless in prod
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        proxy_set_header Host $host;
        proxy_pass http://rallly_app;
    }

    # API routes (keep separate for potential rate limiting)
    location ^~ /api/ {
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Proto $forwarded_proto;
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_pass http://rallly_app;
        proxy_read_timeout 120s;
    }

    # Everything else -> Next.js app
    location / {
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Proto $forwarded_proto;
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_pass http://rallly_app;
        proxy_read_timeout 120s;
        # Prevent intermediary caches from storing HTML by accident
        add_header Cache-Control "no-store";
    }
}

# -------------------------------
# MinIO Console + API: files.your-domain.example.com
# -------------------------------
server {
    listen 80;
    server_name files.your-domain.example.com;

    if ($forwarded_proto != 'https') {
        return 301 https://$host$request_uri;
    }

    # Access logs
    access_log /var/log/nginx/files.access.log;
    error_log  /var/log/nginx/files.error.log warn;

    # MinIO API (S3 compatible)
    location / {
        # Route API and Console differently
        set $upstream minio_api;
        if ($request_uri ~* ^/console) { set $upstream minio_console; }

        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-Proto $forwarded_proto;
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_pass http://$upstream;
        proxy_read_timeout 300s;
        client_max_body_size 1G; # large uploads
    }
}

# END
